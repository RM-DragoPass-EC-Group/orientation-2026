🌐 [English](README.md) | [中文](README_zh.md)

# 欢迎来到 DragoPass 电控组 !!!
git clone 此仓库以获取模板文件

# 政策
本次作业允许协作、在线搜索以及使用生成式 AI。但请在你的解答中 **标注引用来源**。  

:black_medium_square: 引用他人工作不会影响成绩。  

:x: 未标注引用来源将会受到处罚。  

# 文件说明
本仓库包含以下文件与目录：  

```
orientation-2026/
├── Task 1/
│   └── referee.c # 裁判系统通信解析（任务1的参考文件）
├── Task 2/
│   ├── chassis.c # 底盘控制主逻辑实现
│   └── chassis.h # 底盘控制头文件（结构体与函数声明）
├── README.md # 英文版说明文档
└── README_zh.md # 中文版说明文档（本文件）
```

---

# 问题
## 任务 1: 裁判系统通信 (50 Points)

### 描述
在 RoboMaster 比赛中，每个机器人都通过串口协议（UART）与 **裁判系统**（Judge System）进行通信。  
裁判系统会发送包含机器人血量、发射器冷却限制、功率限制等信息的数据包。  
**电控组（EC Group）** 的职责是解析这些数据包，并将其存入结构化变量，供上层代码调用。  

在本任务中，你需要实现一个 **UART 数据包解析器**（简化版裁判系统）。  

### 协议（简化版）
裁判系统发出的数据包结构如下（所有字段均为 **小端序**）：  

| 字节偏移 | 长度 | 字段         | 描述                                  |
|----------|------|--------------|---------------------------------------|
| 0        | 2    | SOF (0xA5)   | 帧头，固定为 0xA5 0x00                |
| 2        | 2    | 数据长度     | 负载（N）的字节数                     |
| 4        | 1    | 序列号       | 包的序号，每次递增                    |
| 5        | 2    | CRC16        | 帧头校验 (字节 0–4)                   |
| 7        | N    | 数据负载     | 数据内容                              |
| 7+N      | 2    | CRC16        | 整个包的 CRC16 校验                   |

**示例负载（机器人状态）**  

| 字节偏移 | 长度 | 字段         | 描述               |
|----------|------|--------------|--------------------|
| 0        | 2    | robot_id     | 机器人唯一 ID      |
| 2        | 2    | current_HP   | 当前血量           |
| 4        | 2    | max_HP       | 最大血量           |

### 任务
1. 实现 **UART 接收中断处理函数**，将接收的字节存入环形缓冲区。  
2. 实现 **Packet_Decode()** 函数，功能包括：  
   - 查找帧头 (SOF = 0xA5 0x00)  
   - 校验两个 CRC16（帧头 + 整包）  
   - 提取有效负载  
3. 定义 `RobotStatus_t` 结构体，用于保存 `robot_id`、`current_HP`、`max_HP`。  
4. 编写解析逻辑，将数据更新到全局变量 `robot_status`。  

### 有用工具
- `crc.c` 中已提供 CRC16 算法（直接调用即可）。  
- UART 底层驱动已初始化 (`HAL_UART_Receive_IT`)。  
- 可用 `#define JUDGE_SOF 0xA5` 简化实现。  

### 评分标准
- 40% 正确实现环形缓冲区与 UART 接收逻辑。  
- 40% 正确的数据包解析和 CRC 校验。  
- 10% 正确的结构体定义与全局变量更新。  
- 10% 代码风格。  

---

## 任务 2: 底盘控制实现 (50 Points)

### 描述
你需要实现底盘控制程序。  
听起来可能有点难，但别担心，我已经为你准备好了很多辅助函数。  

### 提示
在开始之前，你需要知道这些事实：  

- 控制器通过 **CAN 总线** 与电机通信。  
- RoboMaster 开发板 C 上有两个 CAN 总线，分别为 CAN1 和 CAN2。底盘电机接在 CAN1 上。  
- 电机通过 **ID** 区分总线上的消息。在本任务中，你可以随意选择 [0,8] 范围内的 ID，只要互不相同即可。  
- 底盘采用 **麦克纳姆轮** 实现全向移动，可以自行上网查阅相关资料。  

### 有用工具
- `chassis.h` 提供了相关的 typedef，不必担心未定义的结构体。  
- `chassis.c` 中描述了辅助函数。  

### 任务
程序将执行一次 `Chassis_Init`，然后以 **1ms 周期** 不断调用 `Chassis_Task`。  

期望速度存储在全局变量 `vx`, `vy`, `vw` 中。  

实现要求：  
- `Chassis_Init`: 完成初始化。  
- `Chassis_Task`:  
  1. 获取电机数据  
  2. 计算每个电机的目标速度  
  3. 使用 PID 控制电机电流  
  4. 发送电机控制指令  

详细开发规范可参考 [Dev Standard](https://github.com/RM-DragoPass-EC-Group/.github/blob/main/profile/Development%20Standard/Development%20Standard.md)。  

### 评分标准
- 50% 底盘程序实现（因无法测试，允许小错误）。  
- 10% 辅助函数实现（PID_Init, Basic_PID_Controller, forward_kinematic, backward_kinematic）。  
- 9% 代码风格（宽松标准）。  
